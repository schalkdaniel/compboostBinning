# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Calculating binned matrix product
#'
#' This function calculates the matrix product using Algorithm 3 of Zheyuan Li, Simon N. Wood: "Faster
#' model matrix crossproducts for large generalized linear models with discretized covariates". The idea
#' is to compute just on the unique rows of X by also using an index vector to map to the original matrix.
#' The algorithm implemented here is a small adaption of the original algorithm. Instead of calculating $XW$
#' which again, needs to be transposed, we directly calculate $X^TW$ to avoid another transposing step.
#'
#' @param X [\code{arma::mat}]\cr
#'   Matrix X.
#' @param k [\code{arma::uvec}]\cr
#'   Index vector for mapping to original matrix $X_o(i,) = X(k(i),.)$.
#' @param w [\code{arma::vec}]\cr
#'   Vector of weights that are accumulated.
#' @param use_fast_acc [\code{bool}]\cr
#'   Flag to indicate whether to use the original or adopted algorithm.
#' @return \code{arma::mat} Matrix Product $X^TWX$.
#' @examples
#' nsim = 1e6L
#' nunique = trunc(sqrt(nsim))
#'
#' xunique = runif(n = nunique, min = 0, max = 10)
#' k = sample(x = seq_len(nunique), size = nsim, replace = TRUE)
#'
#' X = poly(x = xunique, degree = 20L)
#'
#' binnedMatMult(X = X, k = k-1, w = 1)
#' @export
binnedMatMult <- function(X, k, w, use_fast_acc = FALSE) {
    .Call(`_compboostBinning_binnedMatMult`, X, k, w, use_fast_acc)
}

#' Calculating binned matrix product for response term
#'
#' This function calculates the matrix product using Algorithm 3 of Zheyuan Li, Simon N. Wood: "Faster
#' model matrix crossproducts for large generalized linear models with discretized covariates". The idea
#' is to compute just on the unique rows of X by also using an index vector to map to the original matrix.
#' The algorithm implemented here is a small adaption of the original algorithm. Instead of calculating $XW$
#' which again, needs to be transposed, we directly calculate $X^TW$ to avoid another transposing step. In addition
#' to the original algorithm the algorithm here directly calculates the crossproduct with the response.
#'
#' @param X [\code{arma::mat}]\cr
#'   Matrix X.
#' @param y [\code{arma::vec}]\cr
#'   Response vector y.
#' @param k [\code{arma::uvec}]\cr
#'   Index vector for mapping to original matrix $X_o(i,) = X(k(i),.)$.
#' @param w [\code{arma::vec}]\cr
#'   Vector of weights that are accumulated.
#' @return \code{arma::mat} Matrix Product $X^TWX$.
#' @examples
#' nsim = 1e6L
#' nunique = trunc(sqrt(nsim))
#'
#' xunique = runif(n = nunique, min = 0, max = 10)
#' k = sample(x = seq_len(nunique), size = nsim, replace = TRUE)
#'
#' X = poly(x = xunique, degree = 20L)
#' y = runif(nsim)
#'
#' binnedMatMultResponse(X = X, y = y, k = k-1, w = 1)
#' @export
binnedMatMultResponse <- function(X, y, k, w) {
    .Call(`_compboostBinning_binnedMatMultResponse`, X, y, k, w)
}

#' Calculating sparse binned matrix product
#'
#' This function calculates the matrix product (for sparse matrizes) using Algorithm 3 of Zheyuan Li, Simon N. Wood: "Faster
#' model matrix crossproducts for large generalized linear models with discretized covariates". The idea
#' is to compute just on the unique rows of X by also using an index vector to map to the original matrix.
#' The algorithm implemented here is a small adaption of the original algorithm. Instead of calculating $XW$
#' which again, needs to be transposed, we directly calculate $X^TW$ to avoid another transposing step.
#'
#' @param X [\code{arma::sp_mat}]\cr
#'   Matrix X.
#' @param k [\code{arma::uvec}]\cr
#'   Index vector for mapping to original matrix $X_o(i,) = X(k(i),.)$.
#' @param w [\code{arma::vec}]\cr
#'   Vector of weights that are accumulated.
#' @return \code{arma::mat} Matrix Product $X^TWX$.
#' @examples
#' nsim = 1e6L
#' nunique = trunc(sqrt(nsim))
#'
#' xunique = runif(n = nunique, min = 0, max = 10)
#' k = sample(x = seq_len(nunique), size = nsim, replace = TRUE)
#'
#' X = poly(x = xunique, degree = 20L)
#'
#' binnedMatMult(X = X, k = k-1, w = 1)
#' @export
binnedSparseMatMult <- function(X, k, w) {
    .Call(`_compboostBinning_binnedSparseMatMult`, X, k, w)
}

#' Calculating binned matrix product for response term for sparse matrices
#'
#' This function calculates the matrix product (sparse matrices) using Algorithm 3 of Zheyuan Li, Simon N. Wood: "Faster
#' model matrix crossproducts for large generalized linear models with discretized covariates". The idea
#' is to compute just on the unique rows of X by also using an index vector to map to the original matrix.
#' The algorithm implemented here is a small adaption of the original algorithm. Instead of calculating $XW$
#' which again, needs to be transposed, we directly calculate $X^TW$ to avoid another transposing step. In addition
#' to the original algorithm the algorithm here directly calculates the crossproduct with the response.
#'
#' @param X [\code{arma::sp_mat}]\cr
#'   Matrix X.
#' @param y [\code{arma::vec}]\cr
#'   Response vector y.
#' @param k [\code{arma::uvec}]\cr
#'   Index vector for mapping to original matrix $X_o(i,) = X(k(i),.)$.
#' @param w [\code{arma::vec}]\cr
#'   Vector of weights that are accumulated.
#' @return \code{arma::mat} Matrix Product $X^TWX$.
#' @examples
#' nsim = 1e6L
#' nunique = trunc(sqrt(nsim))
#'
#' xunique = runif(n = nunique, min = 0, max = 10)
#' k = sample(x = seq_len(nunique), size = nsim, replace = TRUE)
#'
#' X = poly(x = xunique, degree = 20L)
#' y = runif(nsim)
#'
#' binnedMatMultResponse(X = X, y = y, k = k-1, w = 1)
#' @export
binnedSparseMatMultResponse <- function(X, y, k, w) {
    .Call(`_compboostBinning_binnedSparseMatMultResponse`, X, y, k, w)
}

#' Calculate vector of bins of specific size
#'
#' This function returns a vector of equally spaced points of length n_bins.
#'
#' @param x [\code{arma::vec}]\cr
#'   Vector that should be discretized.
#' @param n_bins [\code{unsigned int}]\cr
#'   Number of unique points for binning the vector x.
#' @return \code{arma::vec} Vector of discretized x.
#' @examples
#' \dontrun{
#' x = runif(100)
#' binVectorCustom(x, 10)
#' }
binVectorCustom <- function(x, n_bins) {
    .Call(`_compboostBinning_binVectorCustom`, x, n_bins)
}

#' Calculate vector of bins
#'
#' This function returns a vector of equally spaced points of length the square root of the size of the vector.
#'
#' @param x [\code{arma::vec}]\cr
#'   Vector that should be discretized.
#' @return \code{arma::vec} Vector of discretized x.
#' @examples
#' \dontrun{
#' x = runif(100)
#' binVector(x)
#' }
binVector <- function(x) {
    .Call(`_compboostBinning_binVector`, x)
}

#' Calculate index vector for binned vector
#'
#' This function returns the indexes of the unique values to the complete binned vector.
#'
#' @param x [\code{arma::vec}]\cr
#'   Vector that should be discretized.
#' @param x_bins [\code{arma::vec}]\cr
#'   Vector of unique values for binning.
#' @return \code{arma::uvec} Index vector.
#' @examples
#' \dontrun{
#' x = runif(100)
#' bins = binVector(x)
#' idx = calculateIndexVector(x, bins)
#' data.frame(x = x, x_bins = bins[idx])
#' }
calculateIndexVector <- function(x, x_bins) {
    .Call(`_compboostBinning_calculateIndexVector`, x, x_bins)
}

